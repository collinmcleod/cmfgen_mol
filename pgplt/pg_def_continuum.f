	SUBROUTINE PG_DEF_CONTINUUM(CONT,IPLT,OPLT,INPUT_OPTION,CURVE_OPTION,RET_IOS)
	USE MOD_CURVE_DATA
	IMPLICIT NONE
!
	INTEGER RET_IOS
	INTEGER IPLT
	INTEGER OPLT
	REAL*4 CONT(NPTS(IPLT))
	CHARACTER(LEN=*) INPUT_OPTION
	CHARACTER(LEN=*) CURVE_OPTION
!
	INTEGER N_NODES
	INTEGER I,J
	INTEGER I1,I2
	INTEGER ILOW,IHIGH
	INTEGER LU
	REAL*4 X1,X2,Y1,Y2
	REAL*4 Y_SUM,XY_SUM
!
        REAL*4 EW,CENTROID
        REAL*4 XCUR(50),YCUR(50)
	REAL*4 SLOPE
        INTEGER PLOT_ID,CURSERR
        CHARACTER(LEN=1) CURSVAL
!
	INTEGER GET_INDX_SP,PGCURS
	EXTERNAL GET_INDX_SP
	INTEGER, PARAMETER :: IONE=1
!
! Get continuum locations as defined by cursor. CURSOR
! position is used to define continum.
!
	IF (INPUT_OPTION .EQ. 'CURSOR')THEN
	  J=1; CALL PGSCI(J)
	  DO I=1,50 
	    CURSERR = PGCURS(XCUR(I),YCUR(I),CURSVAL)
	    IF(CURSVAL .EQ. 'E' .OR. CURSVAL .EQ. 'e')EXIT
	    CALL PGPT(IONE,XCUR(I),YCUR(I),IONE)
	    N_NODES=I
	    WRITE(6,*)CURSVAL
	  END DO
!
! Use cursors to define bands to define the continuum. In each band,
! the continuum is defined by averaging the data. BANDS are written
! to fort.35, and these can be reread in by the DC option. Top of
! file will need to be updated with hnumber of nodes. 
!
	ELSE IF (INPUT_OPTION .EQ. 'CURX')THEN
	  J=1; CALL PGSCI(J)
	  DO I=1,50 
	    CURSERR = PGCURS(X1,Y1,CURSVAL)
	    IF(CURSVAL .EQ. 'E' .OR. CURSVAL .EQ. 'e')EXIT
	    CALL PGPT(IONE,X1,Y1,IONE)
	    CURSERR = PGCURS(X2,Y2,CURSVAL)
	    IF(CURSVAL .EQ. 'E' .OR. CURSVAL .EQ. 'e')EXIT
	    CALL PGPT(IONE,X2,Y2,IONE)
	    N_NODES=I
	    I1=GET_INDX_SP(X1,CD(IPLT)%XVEC,NPTS(IPLT))
	    I2=GET_INDX_SP(X2,CD(IPLT)%XVEC,NPTS(IPLT))
	    Y_SUM=0.0;XY_SUM=0.0
	    DO J=MIN(I1,I2),MAX(I1,I2)
	      Y_SUM=Y_SUM+CD(IPLT)%DATA(J)
	      XY_SUM=XY_SUM+CD(IPLT)%DATA(J)*CD(IPLT)%XVEC(J)
	    END DO
	    XCUR(I)=XY_SUM/Y_SUM
	    YCUR(I)=Y_SUM/ABS(I2-I1+1)
	    WRITE(35,*)X1,X2
	  END DO
	  WRITE(6,*)'Nodes written to unit 35'
!
	ELSE
	  LU=7
	  OPEN(UNIT=LU,FILE=TRIM(INPUT_OPTION),STATUS='OLD',ACTION='READ',IOSTAT=RET_IOS)
	  IF(RET_IOS .NE. 0)THEN
	    WRITE(6,*)'Unable to open file in PG_DEF_CONT'
	    WRITE(6,*)'IOSTAT=',RET_IOS
	    WRITE(6,*)'FILE=',TRIM(INPUT_OPTION)
	    RETURN
	  END IF
!
	  READ(LU,*)N_NODES
	  WRITE(20,*)N_NODES
	  DO I=1,N_NODES
	    READ(LU,*)X1,X2
	    I1=GET_INDX_SP(X1,CD(IPLT)%XVEC,NPTS(IPLT))
	    I2=GET_INDX_SP(X2,CD(IPLT)%XVEC,NPTS(IPLT))
	    Y_SUM=0.0;XY_SUM=0.0
	    DO J=MIN(I1,I2),MAX(I1,I2)
	      Y_SUM=Y_SUM+CD(IPLT)%DATA(J)
	      XY_SUM=XY_SUM+CD(IPLT)%DATA(J)*CD(IPLT)%XVEC(J)
	    END DO
	    XCUR(I)=XY_SUM/Y_SUM
	    YCUR(I)=Y_SUM/ABS(I2-I1+1)
	    WRITE(20,*)XCUR(I),YCUR(I)
	  END DO
	  WRITE(6,*)'Defined node averages'
	  CLOSE(UNIT=20)
	  CLOSE(UNIT=7)
	END IF
!
	IF(CURVE_OPTION .EQ. 'LINEAR')THEN
	  I2=GET_INDX_SP(XCUR(1),CD(IPLT)%XVEC,NPTS(IPLT))
	  DO I=1,N_NODES-1
	    WRITE(6,*)XCUR(I),XCUR(I+1)
	    I1=I2
	    I2=GET_INDX_SP(XCUR(I+1),CD(IPLT)%XVEC,NPTS(IPLT))
	    SLOPE=(YCUR(I+1)-YCUR(I))/(XCUR(I+1)-XCUR(I))
	    DO J=MIN(I1,I2),MAX(I1,I2)
               CONT(J)=YCUR(I)+SLOPE*(CD(IPLT)%XVEC(J)-XCUR(I))
	    END DO
	  END DO
!
! Fit a monotonic cubic to a set of data bands read from a file.
!
	ELSE
	  ILOW=NPTS(IPLT); IHIGH=-1
	  DO I=1,N_NODES
	    I1=GET_INDX_SP(XCUR(I),CD(IPLT)%XVEC,NPTS(IPLT))
	    ILOW=MIN(I1,ILOW); IHIGH=MAX(I1,IHIGH)
	  END DO
	  ILOW=ILOW+1; IHIGH=IHIGH-1; J=IHIGH-ILOW+1
	  WRITE(6,*)'ILH',ILOW,IHIGH
	  CALL MON_INTERP_SP(CONT(ILOW),J,IONE,CD(IPLT)%XVEC(ILOW),J,YCUR,N_NODES,XCUR,N_NODES)
	END IF
!
! If IP is non-zero, we store plot in a regular data vector. 
!
	IF(OPLT .NE. 0)THEN
	  I=NPTS(IPLT)
	  IF(ALLOCATED(CD(OPLT)%XVEC) .AND. IPLT .NE. OPLT)THEN
	    DEALLOCATE (CD(OPLT)%XVEC)
	    DEALLOCATE (CD(OPLT)%DATA)
	  END IF
	  IF(IPLT .NE. OPLT)THEN
	    ALLOCATE (CD(OPLT)%XVEC(I),STAT=RET_IOS)
	    IF(RET_IOS .EQ. 0)ALLOCATE (CD(OPLT)%DATA(I),STAT=RET_IOS)
	    IF(RET_IOS .NE. 0)THEN
	      WRITE(6,*)'Error: unable to allocate new data vectors'
	      WRITE(6,*)'RET_IOS=',RET_IOS
	      RET_IOS=1
	      RETURN
	      END IF
	    END IF
	    CD(OPLT)%XVEC(1:I)=CD(IPLT)%XVEC(1:I)
	  END IF
	CD(OPLT)%DATA(1:I)=CONT(1:I)
	NPTS(OPLT)=I
	ERR(OPLT)=.FALSE.
	IF(OPLT .GT. NPLTS)NPLTS=OPLT
!
	RETURN
	END
